# 传输层

## 功能

* 提供应用进程间逻辑通信
* 差错检测
* 提供无连接或面向连接的服务
* 复用和分用
* 面向连接的服务特有功能
  * 连接管理
  * 流量控制和拥塞控制

## 传输层寻址和端口号

* 使用端口号标识进程

### 端口号分类

#### 熟知端口

* 0~1023

* 常见熟知端口

  | 应用名                   | 端口号                         |
  | ------------------------ | ------------------------------ |
  | FTP                      | 21（控制端口），20（数据端口） |
  | TELNET                   | 23                             |
  | SMTP                     | 25                             |
  | DNS                      | 53                             |
  | TFTP                     | 69                             |
  | HTTP                     | 80                             |
  | SNMP（简单网络管理协议） | 161                            |
  | HTTPS                    | 403                            |

### 登记端口

* 1024~49151
* 为没有熟知端口号的应用程序使用，使用这类端口号需要在IANA登记，避免重复

### 客户端端口或短暂端口

* 49152~65535
* 客户进程运行时动态运行时的临时端口
* 通信结束后，此端口自动空闲出来

## 套接字（SOCKET）

* 用于标识某一主机的某个进程
* Socket= ( IP地址 , 端口号 )

## 无连接和有连接服务

### 无连接服务（UDP）

* 传输数据无需建立连接
* 数据到达后无需确认
* 不可靠交付
* 报文头部段，传输开销小，时延较短

### 有连接服务（TCP）

* 面向连接
* 不提供短播，多播服务
* 报文头部长，传输开销大

## UDP（用户数据报协议）

### 优点

* 无需连接
* 无需维护连接状态表
* 首部只有8B
* 发送速率不受网络拥塞状态影响（无拥塞控制），适合实时性应用
* 支持一对一，一对多，多对一，多对多的交互通信

### 数据报组成

* 首部字段：8B
* 数据字段

### 数据单元

* 数据报（传输上层交付的整块数据）

### 首部格式

* 源端口：2B
* 目的端口：2B
* 长度：2B，（数据报长度最大为2^16^-1B，但一般取512B以下）
* 校验和：2B，校验伪首部，首部和数据

### 伪首部

* 仅用于校验
* 可从IP数据报中提取
* 不向下传送，也不向上递交
* 长度：12B
* 组成
  * 源IP地址：4B
  * 目的IP地址：4B
  * 全0字段：1B
  * 协议字段：1B，UDP为17
  * UDP长度字段：2B

### UDP校验

#### 发送方步骤

1. 添加12B伪首部
2. 将全零字段填入校验和字段
3. 添加8B首部
4. 添加数据字段（若数据字段为奇数，再补一个全0字节，该字节不发送，仅用于计算校验和）
5. 将这些数据以4B为一组，使用二进制反码计算进行累加
6. 得到的结果的反码即为校验和，将其填入校验和字段

#### 接收方步骤

1. 添加12B伪首部
2. 添加8B首部
3. 添加数据字段（若数据字段为奇数，再补一个全0字节，该字节不发送，仅用于计算校验和）
4. 将这些数据以4B为一组，使用二进制反码计算进行累加
5. 若结果为**1111 1111 1111 1111**（全1），则数据无误

#### 差错处理

* 可丢弃，也可附上错误报告交付上层

#### 优点

* 简单
* 速度快

#### 缺点

* 检错能力差

## TCP（传输控制协议）

### 特点

* 面向连接
* 端到端
* 可靠交付服务
* 全双工通信
* 使用缓存
  * 发送缓存
    * 准备发送的数据
    * 已发送未确认的数据
  * 接收缓存
    * 按序到达但未交付上层的数据
    * 不按序到达的数据
* 面向字节流

### 数据单元

* 报文段（认为所有数据都是无结构字节流，不按结构切分数据）

### TCP报文段

#### 首部长度

* 最短为20B
* 可以4B为单位增加首部选项
* 最大长度为60B

#### 组成

* 源端口：2B

* 目的端口：2B

* 序号：4B，每一字节数据编上一个序号，该字段为本次传输数据的第一个字节序号

* 确认号字段：4B，期待的下一个报文段的第一个序号，确认号为N，则证明前N-1个数据已收到

* 数据偏移：4位，数据字段距离报文段起始处的距离，代表首部长度

* 保留字段：6位，全0

* 紧急位字段URG：1位，URG=1，代表该数据有高优先级

* 确认位ACK：1位，连接建立后必须把ACK置1

* 推送位PSH：1位，置1代表应尽快交付数据，无需等缓存填满

* 复位RST：1位，置1代表线路出现严重错误，需要断开连接重连

* 同步位SYN：1位，SYN=1，代表请求连接或连接接收报文

  | SYN  | ACK  | 含义         |
  | ---- | ---- | ------------ |
  | 1    | 0    | 请求连接     |
  | 1    | 1    | 同意建立连接 |

* 中止位FIN，1位，置1时代表此报文段发送方数据已发送完毕

* 窗口字段：2B，代表报文段发送者当前的接收窗口大小

* 校验和：2B，与UDP一样的计算方式，协议字段改为6

* 紧急指针字段：16位，代表本报文段的紧急数据长度（单位B），紧急数据放于报文段数据开头，与URG一同使用，紧急数据不经过缓冲区直接发送

* 选项字段：长度可变

  * MSS：报文段数据最大长度

* 填充字段：使首部长度为4B的整数倍

### 连接管理

#### 规定

* 当SYN=1时，不携带数据，但消耗一个序号

#### 建立连接

* 三次握手
* 主机A向主机B建立连接步骤
  1. A发送SYN=1，ACK=0，seq=x
  2. B发送SYN=1，ACK=1，seq=y，ack=x+1
  3. A发送ACK=1，ack=y+1（该报文段可携带数据，不携带数据时，不消耗序号）

#### 断开连接

* 四次挥手
* 主机A与主机B断开连接步骤
  1. A发送FIN=1，seq=u
  2. B发送ACK=1，seq=v，ack=u+1
  3. A关闭发送数据通路
  4. B继续发送数据
  5. B发送FIN=1，seq=w，ack=u+1
  6. A发送ACK=1，seq=u+1，ack=w+1
  7. A等待2MSL，关闭连接

#### A等待2MSL的原因

* 保证网络中所有报文段消失
* 若A发送的ACK丢失，B将重发FIN，二者花费时间不会超过2MSL
* 若重传FIN丢失，B将无法正常关闭

#### 四次挥手原因

* 一个FIN和一个ACK断开一端发送数据通道

#### 三次挥手原因

* 采用二次挥手
  * 若ACK丢失，A将不知道B是否准备好连接，也不知道B起始序号
  * B将认为A准备好数据通信
  * A会认为连接未建立，忽略B的所有数据，产生死锁



### 可靠传输

#### 编号和确认

* 使用累计确认
* 支持可选选项**选择确认SACK**（携带已收到的数据段），兼容累计确认

#### 重传

* 重传时延计算，使用加权平均
  * $平均RTT=(1-\alpha)*（平均RTT）+\alpha*(新时延) \ \ \alpha一般取0.125$
  * $重传时间RTO=\beta*平均RTT \ \ 其中\beta>1$
* Karnn算法
  * 发生重传后，就不采用其作为时延样本
  * 令$RTO=\gamma*RTO \ \ 其中\gamma>1,一般取2$
  * 不发生重传时，再使用往返时延更新RTT

### 流量控制

* 采用滑动窗口
* TCP为每个连接建立持续计数器，若一方接到**零窗口通知**，则启动计数器，到期时发送零窗口探测报文段，若窗口大小仍为0，重置计数器
* 发送时机控制
  * TCP维持一个MSS变量，当缓存区数据达MSS大小时，发送
  * 发送方使用PSH字段指名发送
  * 计数器到期，将缓存区不超过MSS的数据发送

### 拥塞控制

#### 变量定义

1. 各变量单位为MSS

1. 接收窗口rwnd：接收方目前的接收窗口大小
2. 拥塞窗口cwnd：发送方根据网络情况估计的窗口大小
3. $实际发送窗口=min(cwnd,rwnd)$
4. ssthresh：慢开始门限

#### 算法

##### 慢开始算法

1. 初始时，设cwnd=1
2. 每收到一个ACK报文cwnd+=1
3. 故在网络畅通且不断发送数据的情况下，第i个RTT后，cwnd=2^i^

##### 拥塞避免算法

* 每隔1个RTT，cwnd+=1

##### 算法选择

* 当cwnd<ssthresh时，使用慢开始算法
* 当cwnd>ssthresh时，使用拥塞避免算法
* 当cwnd=ssthresh时，任意选择一个（一般使用拥塞避免）

#### 拥塞处理

* 发送超时时，ssthresh=cwnd/2
* cwnd=1

##### 快重传算法

* 接收方向发送方连续发送3个重复ACK
* 发送方收到后，立刻重传缺失的报文段

#### 快恢复算法

- 发送方收到连续3个重复确认后，令ssthresh=cwnd/2
- cwnd=ssthresh
- 执行拥塞避免算法