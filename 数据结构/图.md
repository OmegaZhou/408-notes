# 图

## 概念

* 有向图
* 无向图
* 简单图：不存在重复边，不存在顶点到自身的边
* 多重图：于简单图相对，可存在重复边，可存在顶点连到自身
* 完全图（简单完全图）：任意两点都有边（有向图则任意两点存在两条方向相反的边）
* 子图
* 连通：两顶点间存在路径则称为两点连通
* 连通图：任意两点都连通的图
* 连通分量（极大连通子图）：再加一条边就不连通的子图
* 极小连通子图：再删一条边就不连通的子图
* 强连通图：有向图中，任意两点有向路径连通
* 强连通分量：极大强连通子图
* 生成树：包含图中所有顶点的极小连通子图
* 生成森林：删除生成树的一条边即构成生成僧林
* 入度：针对有向图
* 出度：针对有向图
* 度：针对无向图
* 简单路径：顶点不重复出现的路径
* 简单回路：只有起始点出现重复的路径

## 十字链表存储图

* 顶点节点作为链表表头
* 顶点节点V引出两个链表，一条的元素为起始点为V的边，另一条的终点为V的边
* 链表内元素为边

## 邻接多重表

* 每条边存储两遍，分别存储在两个顶点的链表中

## 图的遍历

* DFS
* BFS

## 最小生成树

### Prim算法

* 初始化：选取任一顶点加入树T
* 循环
  * 选取距离T中顶点距离最小的顶点A（A不在T中）
  * 将A加入T

### Kruskal算法

* 将边排序
* 依次选取权值最小的两边

## 最短路径

### Dijkstra算法

#### 时间复杂度

* 普通版本：O(n^2^)
* 堆优化：O(e*log(e))

#### 特点

* 不支持负权图

### Floyed算法（Floyd-Warshall算法）

#### 思想

* 插点法
* 动态规划

#### 步骤

```c++
for(k=1;k<=n;k++){
        for(i=1;i<=n;i++){
            for(j=1;j<=n;j++) {
                if(d[i][k]+d[k][j]<d[i][j]) {
                    d[i][j]=d[i][k]+d[k][j];
                    path[i][j]=path[i][k];		//path[i][j]代表i->j的路径里i的下一个节点
                }
            }
        }
}
```

#### 时间复杂度

* O(n^3^)

#### 特点

* 支持负权图
* 可求出任意两点间的最短路径

### Bellman-Ford算法

#### 原理

* 最多循环n-1次即可找到最短路径
* 循环体：
  * 对边集合 $E$ 中任意边，以$ w(u,v)$表示顶点 $u$出发到顶点 ![v](https://math.jianshu.com/math?formula=v) 的边的权值，以 $d[v]$表示**当前**从起点 $s$ 到顶点 $v$ 的路径权值
  * 若存在边 $ w(u,v)$，使得：
    $d[v]>d[u]+w(u,v$)
  * 则更新$d[v]$值： $d[v]>d[u]+w(u,v$)

#### 特点

* 支持带负权的图
* 遍历第n次可检测是否存在负权回路（若存在d[v]继续减少则存在）

#### 时间复杂度

* O(n*E)

## 关键路径

### AOE网

* 边代表活动，具有权值
* 顶点代表事件（状态）

### AOV网

* 顶点代表活动
* 边代表事件顺序

### 关键路径定义

* 整个工期的最短完成时间

#### 步骤

* 拓扑排序
* 按拓扑排序的顺序求解节点的最早发生时间
* 从汇点出发逆序求得各节点最晚发生时间 