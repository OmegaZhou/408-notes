# 字符串

## KMP算法

* 对模式串求得next数组，然后进行模式匹配

### Next数组

* 首位置空，一般用（-1或0填充），使得可直接使用当前匹配位置的next数组进行操作

* $$
  设模式串当前位置为i，模式串为S\\
  next[i]=S_{0...(i-1)}子串的最大公共前缀的末尾下标+1\\代表前next[i]-1个字符以匹配完成，直接用next[i]位置的字符继续匹配
  $$

* 原理

  * 匹配到第i位发生不匹配，即代表前i-1位匹配，因此只要找到前i-1位后缀的最长公共前缀，即可从此位置开始继续匹配
  * 当模式串进行匹配第i位时发生不匹配时
    * 若i==0，则模式串直接右移从下一个字符开始从头匹配
    * 若i!=0，则模式串则继续匹配模式串next[i]位置的字符和当前位置主串的字符

### 优化

* 原理

  * 若S~i~匹配失败，且S~next[i]~==S~i~，此时S~next[i]~必然匹配失败，因此我们可以省略必然匹配失败的值

  * 因此新增nextval数组，next数组的第i位求法如下

    ```c++
    nextval[i]=get_nextval(i);
    int get_nextval(int i){
        int result=i;
        while(S[result]==S[i]){
            result=next[result];
        }
        return result;
    }
    ```

    

  

